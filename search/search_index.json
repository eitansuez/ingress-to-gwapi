{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>In the early days of Kubernetes, teams started migrating their workloads from VMs to Kubernetes. Teams set to work on containerizing and publishing their applications and services to container registries. They had to develop Kubernetes deployment manifests, and figure out how to templatize and package their manifests, perhaps as a Helm chart.</p> <p>Another piece of the puzzle had to do with configuring the routing of ingress traffic to their applications and APIs now residing inside a Kubernetes cluster.</p> <p>One of the early \"go-to\" solutions for handling ingress traffic was the ingress-nginx controller.  As its name implies, this controller was designed to use the nginx proxy as the runtime gateway that routed traffic to backend workloads.</p> <p>As far as configuration was concerned, at the time, Kubernetes provided the Ingress API.</p> <p>Fast forward to today, many lessons were learned which culminated in the evolved API for configuring ingress for Kubernetes:  the Kubernetes Gateway API.</p> <p>The Kubernetes Gateway API gives users a standard, and many alternative implementations to choose from, as attested by the long list of implementations.</p> <p>Some controllers leverage nginx, others HA-Proxy or something else. Those proxies existed long before Kubernetes. A relatively newer option and open-source CNCF project is Envoy, which has been described as a  \"cloud-native\" proxy for the Kubernetes age. Envoy is a \"batteries-included\" proxy that supports many protocols, and that can manage being hot-reconfigured when routing rules or other configuration details change.</p> <p>Many vendors opt to use Envoy as their cloud-native gateway of choice, and so even within this microcosm, users have a number of vendors they can choose from.</p> <p>Many teams today still use the venerable Ingress API together with the ingress-nginx controller. Using the older implementation is becoming a sort of technical debt.</p> <p>The following pages contain instructions that will guide you through migrating an example project. You will start out using the ingress-nginx controller with the Ingress API, with the objective of migrating to the Gateway API.</p> <p>For the new controller, we will explore kgateway, an open-source project recently contributed to the CNCF by Solo.io, and which implements the Kubernetes Gateway API using Envoy as the backing proxy.</p>"},{"location":"#what-next","title":"What next?","text":"<p>Follow the instructions on the next page to begin setting up your environment.</p> <p>Your first goal will be to reach an initial state where:</p> <ul> <li>You have a Kubernetes cluster hosting two distinct applications, with</li> <li>The ingress-nginx controller installed</li> <li>Ingress resources configuring the flow of ingress traffic to your APIs and applications</li> </ul> <p>You will next configure ingress with HTTPS to simulate a setup that is more aligned with a real-world environment.</p> <p>From there, we explore migration to the Kubernetes Gateway API.</p>"},{"location":"https/","title":"HTTPS","text":"<p>Real-world scenarios for ingress rarely serve traffic over HTTP.</p> <p>In this exercise we retrofit our setup to use HTTPS.</p> <p>This involves:</p> <ol> <li>Generating TLS certificates for each host name</li> <li>Storing the certificate in a Kubernetes Secret</li> <li>Reconfiguring the Ingress resources for TLS</li> </ol>"},{"location":"https/#generate-certificates","title":"Generate certificates","text":"<p>As this exploration is mostly exercise, we will use self-signed certificates.</p> <p>Create a local subdirectory where the certificate files will reside:</p> <pre><code>mkdir certs &amp;&amp; cd certs\n</code></pre> <p>Below we use the <code>step</code> CLI to generate the self-signed certificates for each host name:</p> <pre><code>step certificate create httpbin.example.com httpbin.crt httpbin.key \\\n  --profile self-signed --subtle --no-password --insecure\n</code></pre> <p>And for <code>bookinfo</code>:</p> <pre><code>step certificate create bookinfo.example.com bookinfo.crt bookinfo.key \\\n  --profile self-signed --subtle --no-password --insecure\n</code></pre>"},{"location":"https/#store-the-certificates-as-secrets","title":"Store the certificates as secrets","text":"<pre><code>kubectl create secret tls httpbin-cert -n httpbin \\\n  --cert=httpbin.crt --key=httpbin.key\n</code></pre> <p>And for <code>bookinfo</code>:</p> <pre><code>kubectl create secret tls bookinfo-cert -n bookinfo \\\n  --cert=bookinfo.crt --key=bookinfo.key\n</code></pre>"},{"location":"https/#reconfigure-ingress","title":"Reconfigure Ingress","text":""},{"location":"https/#httpbin","title":"<code>httpbin</code>","text":"<p>Below, note the addition of a <code>tls</code> section that references the secret you just created in association with the hostname <code>httpbin.example.com</code>:</p> httpbin-https-ingress.yaml<pre><code>---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: httpbin-ingress\n  namespace: httpbin\nspec:\n  ingressClassName: nginx\n  tls:\n  - hosts:\n    - httpbin.example.com\n    secretName: httpbin-cert\n  rules:\n  - host: \"httpbin.example.com\"\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: httpbin\n            port:\n              number: 8000\n</code></pre> <p>Apply the Ingress resource:</p> <pre><code>kubectl apply -f httpbin-https-ingress.yaml\n</code></pre>"},{"location":"https/#bookinfo","title":"<code>bookinfo</code>","text":"<p>Similarly, for <code>bookinfo</code> we add a <code>tls</code> configuration section referencing its certificate:</p> bookinfo-https-ingress.yaml<pre><code>---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: bookinfo-ingress\n  namespace: bookinfo\nspec:\n  ingressClassName: nginx\n  tls:\n  - hosts:\n    - bookinfo.example.com\n    secretName: bookinfo-cert\n  rules:\n  - host: \"bookinfo.example.com\"\n    http:\n      paths:\n      - path: /productpage\n        pathType: Exact\n        backend:\n          service:\n            name: productpage\n            port:\n              number: 9080\n      - path: /static\n        pathType: Prefix\n        backend:\n          service:\n            name: productpage\n            port:\n              number: 9080\n      - path: /login\n        pathType: Exact\n        backend:\n          service:\n            name: productpage\n            port:\n              number: 9080\n      - path: /logout\n        pathType: Exact\n        backend:\n          service:\n            name: productpage\n            port:\n              number: 9080\n      - path: /api/v1/products\n        pathType: Prefix\n        backend:\n          service:\n            name: productpage\n            port:\n              number: 9080\n</code></pre> <p>Apply the resource:</p> <pre><code>kubectl apply -f bookinfo-https-ingress.yaml\n</code></pre>"},{"location":"https/#test-it","title":"Test it","text":"<p>Verify that you can now call <code>httpbin</code> over HTTPS:</p> <pre><code>curl --insecure https://httpbin.example.com/get \\\n  --resolve httpbin.example.com:443:$GW_IP | jq\n</code></pre> <p>Note that we have to add the <code>--insecure</code> flag because we are using self-signed certificates.</p> <p>Likewise for <code>bookinfo</code>:</p> <pre><code>curl -s --insecure https://bookinfo.example.com/productpage \\\n  --resolve bookinfo.example.com:443:$GW_IP | grep title\n</code></pre> <p>Try to access <code>bookinfo</code> over HTTP:</p> <pre><code>curl -v http://bookinfo.example.com/productpage \\\n  --resolve bookinfo.example.com:80:$GW_IP\n</code></pre> <p>This should produce a <code>308 Permanent Redirect</code> response.</p> <p>You can instruct <code>curl</code> to follow redirects, and the response will be served over HTTPS:</p> <pre><code>curl -s -L --insecure http://bookinfo.example.com/productpage \\\n  --resolve bookinfo.example.com:80:$GW_IP \\\n  --resolve bookinfo.example.com:443:$GW_IP | grep title\n</code></pre>"},{"location":"https/#where-we-stand","title":"Where we stand","text":"<p>We now have a setup that uses the nginx-ingress controller, and that uses Kubernetes Ingress resources to serve two applications over HTTPS.</p> <p>It is time to turn a corner and start discussing how to migrate this setup to the Kubernetes Gateway API.</p>"},{"location":"ingress/","title":"Configure ingress","text":"<p>To configure ingress for each application, apply Ingress resources, one for each application, as shown below.</p>"},{"location":"ingress/#httpbin","title":"<code>httpbin</code>","text":"<p>Review the configuration, which matches on a fictitious host name <code>httpbin.example.com</code> and routes matching requests to the <code>httpbin</code> backend service.</p> httpbin-ingress.yaml<pre><code>---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: httpbin-ingress\n  namespace: httpbin\nspec:\n  ingressClassName: nginx\n  rules:\n  - host: \"httpbin.example.com\"\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: httpbin\n            port:\n              number: 8000\n</code></pre> <p>Apply it:</p> <pre><code>kubectl apply -f httpbin-ingress.yaml\n</code></pre>"},{"location":"ingress/#test-ingress","title":"Test ingress","text":"<p>The ingress-nginx controller has an associated LoadBalancer type service and hence, bearing an external IP address:</p> <pre><code>kubectl get svc -n ingress-nginx\n</code></pre> <p>Capture the external IP address to the environment variable <code>GW_IP</code>:</p> <pre><code>export GW_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -ojsonpath='{.status.loadBalancer.ingress[0].ip}')\n</code></pre> <p>When making an HTTP request, we can use curl's <code>--resolve</code> flag to simulate DNS resolution of the host name to the gateway IP address.</p> <p>Test the following example call to <code>httpbin</code>'s <code>/get</code> endpoint:</p> <pre><code>curl http://httpbin.example.com/get --resolve httpbin.example.com:80:$GW_IP | jq\n</code></pre> <p>The response should present a json-formatted payload reflecting the properties of the request, including the url, headers, and HTTP method.</p>"},{"location":"ingress/#bookinfo","title":"<code>bookinfo</code>","text":"<p>The configuration for <code>bookinfo</code> is lengthier because it configures multiple specific paths and path prefixes, all routing to the backend service <code>productpage</code> listening on port 9080:</p> bookinfo-ingress.yaml<pre><code>---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: bookinfo-ingress\n  namespace: bookinfo\nspec:\n  ingressClassName: nginx\n  rules:\n  - host: \"bookinfo.example.com\"\n    http:\n      paths:\n      - path: /productpage\n        pathType: Exact\n        backend:\n          service:\n            name: productpage\n            port:\n              number: 9080\n      - path: /static\n        pathType: Prefix\n        backend:\n          service:\n            name: productpage\n            port:\n              number: 9080\n      - path: /login\n        pathType: Exact\n        backend:\n          service:\n            name: productpage\n            port:\n              number: 9080\n      - path: /logout\n        pathType: Exact\n        backend:\n          service:\n            name: productpage\n            port:\n              number: 9080\n      - path: /api/v1/products\n        pathType: Prefix\n        backend:\n          service:\n            name: productpage\n            port:\n              number: 9080\n</code></pre> <p>Apply the configuration:</p> <pre><code>kubectl apply -f bookinfo-ingress.yaml\n</code></pre> <p>ingress-nginx uses a shared gateway model:  multiple Ingress resources will program the same singular gateway.</p>"},{"location":"ingress/#test-ingress_1","title":"Test ingress","text":"<p>We can test ingress to the <code>bookinfo</code> application in a fashion similar to what we did above:</p> <pre><code>curl http://bookinfo.example.com/productpage --resolve bookinfo.example.com:80:$GW_IP\n</code></pre> <p>The response payload for the <code>/productpage</code> endpoint is an HTML page.</p> <p>To verify the page is indeed from the <code>bookinfo</code> application, <code>grep</code> the response for the page title:</p> <pre><code>curl -s http://bookinfo.example.com/productpage --resolve bookinfo.example.com:80:$GW_IP | grep title\n</code></pre>"},{"location":"ingress/#summary","title":"Summary","text":"<p>Take stock of this \"initial state\".</p> <ul> <li>We have a Kubernetes cluster</li> <li>The ingress-nginx controller is installed</li> <li>Two distinct applications are deployed: <code>httpbin</code> and <code>bookinfo</code></li> <li>Ingress resources configure ingress to each application through a single gateway</li> </ul> <p>Before proceeding with migration, we need to turn this scenario into a more realistic one, one where the gateway serves traffic over HTTPS, and not as plain-text HTTP traffic.</p>"},{"location":"migration/","title":"Migration","text":"<p>The main concerns relating to migrating from Ingress to the Gateway API are:</p> <ol> <li>Identifying and selecting a controller that implements the new Kubernetes Gateway API.</li> <li>Translating the Ingress configurations to Gateway API resources.</li> <li>Vetting the revised configurations.</li> <li>Switching over from the old gateway to the new one without downtime.</li> </ol> <p>In addition, it is desirable to have the flexibility to transition one host name at a time. In other words, in large enterprise environments, we need to accommodate teams transitioning to the new API at their own pace.</p>"},{"location":"migration/#the-gateway-api","title":"The Gateway API","text":"<p>The Kubernetes Gateway API improves upon the Ingress model in a number of ways:</p> <ul> <li>Routing and Gateway-specific concerns are separate concerns, and are configured through distinct resources.  Routes attach to Gateways.</li> <li>Personas are taken into account: platform administrators configure gateways while applications teams self-service routing rules for their apps.</li> <li>The creation of the Gateway resource also provisions the gateway, on-demand.</li> </ul> <p>This last point affords us the flexibility to use either shared gateways or dedicated ones for specific applications. Certain applications require a higher degree of isolation.  This can be imposed by regulatory or other requirements, where traffic flowing to the target application cannot pass through a shared component, perhaps for security reasons, or to avoid other types of issues that stem from \"noisy neighbors.\" On the other hand, for applications that do not require it, it's simpler and more cost effective to use a single shared gateway.</p>"},{"location":"migration/#gateway-api-compatible-controller","title":"Gateway API compatible controller","text":"<p>The Gateway API documentation lists implementations that conform to it. For this migration we will use kgateway, an open-source project recently contributed to the CNCF.</p>"},{"location":"migration/#install-kgateway","title":"Install kgateway","text":"<p>Let us use the instructions from the quickstart to install kgateway.</p> <ol> <li> <p>Apply the Gateway API CRDs:</p> <pre><code>kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.1/standard-install.yaml\n</code></pre> </li> <li> <p>Install kgateway's own CRDs with Helm:</p> <pre><code>helm upgrade -i --create-namespace --namespace kgateway-system --version v2.0.0 kgateway-crds oci://cr.kgateway.dev/kgateway-dev/charts/kgateway-crds\n</code></pre> </li> <li> <p>Install kgateway:</p> <pre><code>helm upgrade -i --namespace kgateway-system --version v2.0.0 kgateway oci://cr.kgateway.dev/kgateway-dev/charts/kgateway\n</code></pre> </li> </ol> <p>We can verify the installation by listing deployments in the newly-created <code>kgateway-system</code> namespace:</p> <pre><code>kubectl get deploy -n kgateway-system\n</code></pre> <p>We can also list GatewayClass resources, which are the Gateway API's equivalent to the IngressClass concept:</p> <pre><code>kubectl get gatewayclass\n</code></pre> <p>The output will show a GatewayClass named <code>kgateway</code> (and another one for provisioning waypoints, which is out of scope at the moment).</p> <p>We now have a running control plane.</p> <p>The next step is to provision a gateway; for that we use the Gateway resource.</p>"},{"location":"migration/#translate-the-ingress-configurations","title":"Translate the Ingress configurations","text":"<p>Before we dive in to creating the necessary Gateway API resources, we should consider options.</p> <p>We can try to use a tool to translate the existing Ingress resources. When the number or quantity of configuration files is large, and where the alternative of drafting the configurations by hand can be both tedious and error-prone, using a tool is usually the better option. On the other hand, tools are often incomplete, they don't always implement a spec fully, and are more mechanistic, in that they don't have intimate understanding of the original and target APIs and their nuances.</p> <p>As long as the quantity of configuration is small, the translations can be performed manually. For large numbers of files, we can try to use a tool in combination with human review and testing to ensure correctness.</p> <p>These days we have a third option:  leveraging an LLM to translate our configurations. This can be a viable option, but also comes with caveats:  it may be a security risk to divulge internal configurations if using an external provider. Also LLMs are not impervious to making mistakes, and so their output needs to be reviewed and sometimes corrected.</p>"},{"location":"migration/#explore-ingress2gateway","title":"Explore <code>ingress2gateway</code>","text":"<p>The Kubernetes community provides a tool named ingress2gateway designed specifically for this purpose.</p> <p>Follow the instructions to install the tool's CLI on your machine.</p> <p>The tool provides a number of options to control scope and source of configuration:  we can have it inspect a running cluster and look at Ingress objects applied directly to the cluster, or we can point it at an input file on disk and have it translate that.  We can also scope the search for Ingress resources to a namespace, or have it look at all namespaces.</p> <p>Here are a number of alternative invocations of the tool to generate configuration:</p> <p>Look for Ingress resources in the entire cluster:</p> <pre><code>ingress2gateway print --providers ingress-nginx --all-namespaces\n</code></pre> <p>Scope the search to the <code>httpbin</code> namespace:</p> <pre><code>ingress2gateway print --namespace httpbin --providers ingress-nginx\n</code></pre> <p>Or, for <code>bookinfo</code>:</p> <pre><code>ingress2gateway print --namespace bookinfo --providers ingress-nginx\n</code></pre> <p>Use an input file and translate that:</p> <pre><code>ingress2gateway print --input-file ./httpbin-https-ingress.yaml --namespace httpbin --providers ingress-nginx\n</code></pre> <p>Or, for <code>bookinfo</code>:</p> <pre><code>ingress2gateway print --input-file ./bookinfo-https-ingress.yaml --namespace bookinfo --providers ingress-nginx\n</code></pre>"},{"location":"migration/#review-and-vet-the-generated-configurations","title":"Review and vet the generated configurations","text":"<p>The biggest difference by far between Ingress and Gateway API resources is that a single Ingress configuration maps to a pair of resources:  Gateway and an HTTPRoute.</p> <p>Let us study the output from <code>ingress2gateway</code>:</p> <pre><code>ingress2gateway print --providers ingress-nginx --all-namespaces\n</code></pre> <p>Like most tools, this one appears to perform direct translations:  for every Ingress resource, it produces a Gateway and an HTTPRoute. The tool does not perform intelligent analysis of the cluster, and will not take into account that there are two distinct applications where a plausible configuration would be to provision a single, shared gateway.</p> generated-config.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  annotations:\n    gateway.networking.k8s.io/generator: ingress2gateway-0.4.0\n  creationTimestamp: null\n  name: nginx\n  namespace: bookinfo\nspec:\n  gatewayClassName: nginx\n  listeners:\n  - hostname: bookinfo.example.com\n    name: bookinfo-example-com-http\n    port: 80\n    protocol: HTTP\n  - hostname: bookinfo.example.com\n    name: bookinfo-example-com-https\n    port: 443\n    protocol: HTTPS\n    tls:\n      certificateRefs:\n      - group: null\n        kind: null\n        name: bookinfo-cert\nstatus: {}\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  annotations:\n    gateway.networking.k8s.io/generator: ingress2gateway-0.4.0\n  creationTimestamp: null\n  name: nginx\n  namespace: httpbin\nspec:\n  gatewayClassName: nginx\n  listeners:\n  - hostname: httpbin.example.com\n    name: httpbin-example-com-http\n    port: 80\n    protocol: HTTP\n  - hostname: httpbin.example.com\n    name: httpbin-example-com-https\n    port: 443\n    protocol: HTTPS\n    tls:\n      certificateRefs:\n      - group: null\n        kind: null\n        name: httpbin-cert\nstatus: {}\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  annotations:\n    gateway.networking.k8s.io/generator: ingress2gateway-0.4.0\n  creationTimestamp: null\n  name: bookinfo-ingress-bookinfo-example-com\n  namespace: bookinfo\nspec:\n  hostnames:\n  - bookinfo.example.com\n  parentRefs:\n  - name: nginx\n  rules:\n  - backendRefs:\n    - name: productpage\n      port: 9080\n    matches:\n    - path:\n        type: Exact\n        value: /productpage\n  - backendRefs:\n    - name: productpage\n      port: 9080\n    matches:\n    - path:\n        type: PathPrefix\n        value: /static\n  - backendRefs:\n    - name: productpage\n      port: 9080\n    matches:\n    - path:\n        type: Exact\n        value: /login\n  - backendRefs:\n    - name: productpage\n      port: 9080\n    matches:\n    - path:\n        type: Exact\n        value: /logout\n  - backendRefs:\n    - name: productpage\n      port: 9080\n    matches:\n    - path:\n        type: PathPrefix\n        value: /api/v1/products\nstatus:\n  parents: []\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  annotations:\n    gateway.networking.k8s.io/generator: ingress2gateway-0.4.0\n  creationTimestamp: null\n  name: httpbin-ingress-httpbin-example-com\n  namespace: httpbin\nspec:\n  hostnames:\n  - httpbin.example.com\n  parentRefs:\n  - name: nginx\n  rules:\n  - backendRefs:\n    - name: httpbin\n      port: 8000\n    matches:\n    - path:\n        type: PathPrefix\n        value: /\nstatus:\n  parents: []\n</code></pre> <p>The other glaring difference between what the tool produced compared to what a human would, is the repetition of the <code>backendRefs</code> section across multiple routing rules, failing to realize that the same configuration can be simplified to a single rule with multiple <code>matches</code> and a single <code>backendRef</code>.</p> <p>Finally, the tool has no way of knowing (or does not provide a way to specify) what <code>gatewayClassName</code> to use for the translated resource, and so we must edit that value as well (to <code>kgateway</code>).</p> <p>In summary, using <code>ingress2gateway</code> is useful and insightful, but produces only a starting point for review and evaluation. We must then make implementation decisions and, from the generated output, derive and craft the final Gateway API resource artifacts.</p> <p>We opt to provision a single gateway, with two separate HTTPRoute resources, one per application.</p>"},{"location":"migration/#provision-the-gateway","title":"Provision the Gateway","text":"<p>Study the following Gateway resource configuration:</p> gateway.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: my-gateway\n  namespace: kgateway-system\nspec:\n  gatewayClassName: kgateway\n  listeners:\n  - name: http\n    port: 80\n    protocol: HTTP\n  - name: httpbin-https\n    protocol: HTTPS\n    port: 443\n    hostname: httpbin.example.com\n    tls:\n      mode: Terminate\n      certificateRefs:\n      - name: httpbin-cert\n  - name: bookinfo-https\n    protocol: HTTPS\n    port: 443\n    hostname: bookinfo.example.com\n    tls:\n      mode: Terminate\n      certificateRefs:\n      - name: bookinfo-cert\n</code></pre> <p>We make a number of design decisions:</p> <ul> <li>Decide to provision a single gateway, and place it in the <code>kgateway-system</code> namespace, controlled (and accessible only) by cluster administrators.</li> <li>Define a port 80 listener.  We will later define a routing rule to redirect all HTTP requests to HTTPS.</li> <li>Specify two listeners, one for each application (<code>httpbin</code> and <code>bookinfo</code>), matching on the corresponding hostname, each configured to terminate TLS, and each referencing its corresponding TLS certificate.</li> </ul> <p>These decisions have implications:  the secrets we created previously exist alongside each Ingress resource, in their corresponding application namespaces.  We must now place a copy of these secrets in <code>kgateway-system</code> to make it accessible to the new Gateway.</p> <pre><code>kubectl create secret tls httpbin-cert -n kgateway-system \\\n  --cert=httpbin.crt --key=httpbin.key\n</code></pre> <p>And for <code>bookinfo</code>:</p> <pre><code>kubectl create secret tls bookinfo-cert -n kgateway-system \\\n  --cert=bookinfo.crt --key=bookinfo.key\n</code></pre> <p>Apply the Gateway resource:</p> <pre><code>kubectl apply -f gateway.yaml\n</code></pre> <p>List the deployments running in <code>kgateway-system</code>:</p> <pre><code>kubectl get deploy -n kgateway-system\n</code></pre> <p>Applying the Gateway resource triggered the provisioning of the Envoy proxy deployment <code>my-gateway</code>.</p> <p>Also note the accompanying LoadBalancer-type service with external IP address:</p> <pre><code>kubectl get svc -n kgateway-system\n</code></pre>"},{"location":"migration/#configure-routing","title":"Configure routing","text":""},{"location":"migration/#httpbin","title":"<code>httpbin</code>","text":"<p>Study the below HTTPRoute for <code>httpbin</code>:</p> httpbin-route.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin-route\n  namespace: httpbin\nspec:\n  parentRefs:\n  - name: my-gateway\n    namespace: kgateway-system\n    sectionName: httpbin-https\n  rules:\n  - backendRefs:\n    - name: httpbin\n      port: 8000\n</code></pre> <p>The above configuration is essentially what <code>ingress2gateway</code> produced, but with the following differences:</p> <ul> <li>Bind to the gateway <code>my-gateway</code>, provisioned in the <code>kgateway-system</code> namespace</li> <li>Explicitly attach the route to the <code>httpbin-https</code> listener</li> <li>Remove redundant <code>matches</code> and <code>hostnames</code> clauses.</li> </ul> <p>Apply the route:</p> <pre><code>kubectl apply -f httpbin-route.yaml\n</code></pre>"},{"location":"migration/#bookinfo","title":"<code>bookinfo</code>","text":"<p>Study the below HTTPRoute for <code>bookinfo</code>:</p> bookinfo-route.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: bookinfo-route\n  namespace: bookinfo\nspec:\n  parentRefs:\n  - name: my-gateway\n    namespace: kgateway-system\n    sectionName: bookinfo-https\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: /productpage\n    - path:\n        type: PathPrefix\n        value: /static\n    - path:\n        type: Exact\n        value: /login\n    - path:\n        type: Exact\n        value: /logout\n    - path:\n        type: PathPrefix\n        value: /api/v1/products\n    backendRefs:\n    - name: productpage\n      port: 9080\n</code></pre> <p>Aside from binding to the <code>bookinfo-https</code> listener on the gateway in <code>kgateway-system</code>, the big difference above, compared to what the tool produced, is the elimination of the repeated or duplicate <code>backendRef</code> section:  we can specify a single routing rule with multiple path matches, all routing to the same, single <code>productpage</code> backend reference.</p> <p>Apply the route:</p> <pre><code>kubectl apply -f bookinfo-route.yaml\n</code></pre>"},{"location":"migration/#http-redirect-to-https","title":"HTTP redirect to HTTPS","text":"<p>Study the below routing rule:</p> http-redirect.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: redirect-to-https\n  namespace: kgateway-system\nspec:\n  parentRefs:\n  - name: my-gateway\n    sectionName: http\n  rules:\n  - filters:\n    - type: RequestRedirect\n      requestRedirect:\n        scheme: https\n        statusCode: 301\n</code></pre> <p>Note:</p> <ul> <li>We place this HTTPRoute in <code>kgateway-system</code>; it is not a concern of the application development teams.</li> <li>The routing rule binds to (applies to) the <code>http</code> listener only.</li> <li>The rule uses the RequestRedirect filter to redirect the request to the <code>https</code> scheme, otherwise preserving the original URL.</li> </ul> <p>Apply the redirection rule:</p> <pre><code>kubectl apply -f http-redirect.yaml\n</code></pre>"},{"location":"migration/#test-the-configuration","title":"Test the configuration","text":"<p>When we begin testing our setup, the first thing we learn is that the routes did not attach to the gateway:</p> <pre><code>kubectl get httproute -n httpbin httpbin-route -o yaml\n</code></pre> <p>Here is the output of the <code>status</code> section:</p> Route status<pre><code>status:\n  parents:\n  - conditions:\n    - lastTransitionTime: \"2025-04-16T22:15:18Z\"\n      message: \"\"\n      observedGeneration: 1\n      reason: NotAllowedByListeners\n      status: \"False\"\n      type: Accepted\n    - lastTransitionTime: \"2025-04-16T22:15:18Z\"\n      message: \"\"\n      observedGeneration: 1\n      reason: ResolvedRefs\n      status: \"True\"\n      type: ResolvedRefs\n    controllerName: kgateway.dev/kgateway\n    parentRef:\n      group: gateway.networking.k8s.io\n      kind: Gateway\n      name: my-gateway\n      namespace: kgateway-system\n      sectionName: httpbin-https\n</code></pre> <p>The condition \"Accepted=False\" with the reason \"NotAllowedByListeners\" is due to the fact that the gateway is not configured to allow routes from different namespaces to attach to it.</p> <p>It stems from the decision we made to use a shared gateway and to place it in a separate namespace. Application namespaces must be designated such that routes defined within them are permitted to attach.</p> <p>Here is a revised Gateway resource with explicit <code>allowedRoutes</code> rules for each listener:</p> gateway-allows-routes.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: my-gateway\n  namespace: kgateway-system\nspec:\n  gatewayClassName: kgateway\n  listeners:\n  - name: http\n    port: 80\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: Same\n  - name: httpbin-https\n    protocol: HTTPS\n    port: 443\n    hostname: httpbin.example.com\n    tls:\n      mode: Terminate\n      certificateRefs:\n      - name: httpbin-cert\n    allowedRoutes:\n      namespaces:\n        from: Selector\n        selector:\n          matchLabels:\n            self-serve-ingress: \"true\"\n  - name: bookinfo-https\n    protocol: HTTPS\n    port: 443\n    hostname: bookinfo.example.com\n    tls:\n      mode: Terminate\n      certificateRefs:\n      - name: bookinfo-cert\n    allowedRoutes:\n      namespaces:\n        from: Selector\n        selector:\n          matchLabels:\n            self-serve-ingress: \"true\"\n</code></pre> <p>Above, we define a convention: to label each namespace with <code>self-serve-ingress=\"true\"</code> to allow both applications to define routes against the shared gateway:</p> <pre><code>kubectl label ns httpbin self-serve-ingress=true\n</code></pre> <p>And:</p> <pre><code>kubectl label ns bookinfo self-serve-ingress=true\n</code></pre> <p>Finally, apply the revised gateway resource:</p> <pre><code>kubectl apply -f gateway-allows-routes.yaml\n</code></pre> <p>Check the route status once more:</p> <pre><code>kubectl get httproute -n httpbin httpbin-route -o yaml\n</code></pre> <p>This time the Accepted condition is True.</p> <p>We can also check on the status of the gateway itself:  each listener should have one attached route:</p> <pre><code>kubectl get gtw -n kgateway-system my-gateway -o yaml\n</code></pre>"},{"location":"migration/#send-test-requests","title":"Send test requests","text":"<p>Send in some test requests through the new gateway.</p> <p>First, capture the new gateway IP address:</p> <pre><code>export GW_IP=$(kubectl get gtw -n kgateway-system my-gateway -ojsonpath='{.status.addresses[0].value}')\n</code></pre> <p>Call <code>httpbin</code>:</p> <pre><code>curl --insecure https://httpbin.example.com/headers --resolve httpbin.example.com:443:$GW_IP | jq\n</code></pre> <p>Verify that redirects work correctly by making a call over HTTP:</p> <pre><code>curl -v http://httpbin.example.com/headers --resolve httpbin.example.com:80:$GW_IP\n</code></pre> <p>Call <code>bookinfo</code>:</p> <pre><code>curl --insecure https://bookinfo.example.com/productpage --resolve bookinfo.example.com:443:$GW_IP | grep title\n</code></pre> <p>Verify that redirects work correctly for <code>bookinfo</code> as well:</p> <pre><code>curl -v http://bookinfo.example.com/productpage --resolve bookinfo.example.com:80:$GW_IP\n</code></pre> <p>Note the HTTP 301 (Moved permanently) response.</p>"},{"location":"migration/#switching-over","title":"Switching over","text":"<p>We have two gateways, and both are configured with equivalent rules, to route requests to <code>httpbin</code> and to <code>bookinfo</code>. One gateway is controlled by the ingress-nginx controller and uses the nginx proxy, while the other is controlled by kgateway and uses the Envoy proxy. Each has its own distinct public IP address.</p> <p>Switching from ingress-nginx to kgateway is a matter of updating the DNS configuration for each host name:  alter the A record for <code>httpbin.example.com</code> to point to the new gateway IP address.</p> <p>Monitor traffic through both gateways. You should notice that all traffic to the hostname now goes through the new gateway, while the old gateway will cease to receive traffic.</p> <p>Next, we can make the analogous DNS change for the <code>bookinfo</code> hostname, and observe that traffic begins to flow through the new gateway for <code>bookinfo</code> workloads too.</p> <p>This points to the fact that it is possible to migrate from ingress-nginx to kgateway in a piecemeal fashion: teams can work at different pace and each migrate to the new gateway on their own schedule.</p> <p>When all teams have completed their migration, we can finally decommission the old gateway.</p>"},{"location":"migration/#decomission-ingress-nginx","title":"Decomission ingress-nginx","text":"<p>Decommissioning the old gateway involves undoing the original ingress setup:</p> <ol> <li> <p>Delete Ingress resources from each <code>bookinfo</code> and <code>httpbin</code> namespaces.</p> <pre><code>kubectl delete ingress -n httpbin httpbin-ingress\n</code></pre> </li> <li> <p>Delete the secrets holding the server certificates from these namespaces too.</p> <pre><code>kubectl delete ingress -n bookinfo bookinfo-ingress\n</code></pre> </li> <li> <p>Uninstall ingress-nginx.</p> <pre><code>helm uninstall -n ingress-nginx ingress-nginx\n</code></pre> <p>And:</p> <pre><code>kubectl delete ns ingress-nginx\n</code></pre> </li> </ol>"},{"location":"migration/#summary","title":"Summary","text":"<p>This migration isn't the end of the road. kgateway provides capabilities that will take your environment well beyond what the original system could do:</p> <ol> <li>Integrate kgateway with your Istio service mesh to gain encrypted communication with mutual TLS from the gateway to your mesh backend workloads.</li> <li>With ambient mesh, you can use kgateway as your waypoint, unlocking kgateway's capabilities for workloads running internally.</li> <li>Use kgateway as an egress gateway to control traffic exiting your environment.</li> <li>Use kgateway's AI capabilities to secure your LLM applications as they make requests to external LLM providers.</li> </ol> <p>For more information about these capabilities, visit the kgateway.dev web site.</p>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#provision-a-cluster","title":"Provision a cluster","text":"<p>Feel free to provision a Kubernetes cluster any way you prefer. The main requirement is that the environment supports the assignment of an external IP address to LoadBalancer-type services.</p> GCPLocal <p>Here is an example command to provision a 3-node cluster on GCP (GKE) using the <code>gcloud</code> CLI:</p> <pre><code>gcloud container clusters create my-k8s-cluster \\\n  --cluster-version latest \\\n  --machine-type \"e2-standard-2\" \\\n  --num-nodes \"3\" \\\n  --network \"default\"\n</code></pre> <p>Here is an example command to provision a local cluster with k3d:</p> <pre><code>k3d cluster create my-k8s-cluster \\\n    --api-port 6443 \\\n    --k3s-arg \"--disable=traefik@server:0\" \\\n    --port 80:80@loadbalancer \\\n    --port 443:443@loadbalancer\n</code></pre>"},{"location":"setup/#deploy-two-distinct-workloads","title":"Deploy two distinct workloads","text":"<p>Deploy two distinct applications, each to its own namespace:</p>"},{"location":"setup/#httpbin","title":"<code>httpbin</code>","text":"<p><code>httpbin</code> is a sample application useful for testing HTTP communications.</p> <pre><code>kubectl create ns httpbin\n</code></pre> <pre><code>kubectl apply -n httpbin -f https://raw.githubusercontent.com/istio/istio/refs/heads/master/samples/httpbin/httpbin.yaml\n</code></pre>"},{"location":"setup/#bookinfo","title":"<code>bookinfo</code>","text":"<p><code>bookinfo</code> is one of Istio's sample applications, consisting of four microservices.</p> <pre><code>kubectl create ns bookinfo\n</code></pre> <pre><code>kubectl apply -n bookinfo -f https://raw.githubusercontent.com/istio/istio/refs/heads/master/samples/bookinfo/platform/kube/bookinfo.yaml\n</code></pre> <p>Both sets of workloads should now be running in their respective namespaces:</p> <pre><code>kubectl get pod -n httpbin\n</code></pre> <p>And:</p> <pre><code>kubectl get pod -n bookinfo\n</code></pre>"},{"location":"setup/#install-ingress-nginx","title":"Install ingress-nginx","text":"<p>Follow instructions from the project quickstart:</p> <pre><code>helm upgrade --install ingress-nginx ingress-nginx \\\n  --repo https://kubernetes.github.io/ingress-nginx \\\n  --namespace ingress-nginx --create-namespace\n</code></pre> <p>Verify that the controller is running (it can take a minute before the pod reaches READY state):</p> <pre><code>kubectl get pod -n ingress-nginx\n</code></pre> <p>Also note the presence of a default ingress class named <code>nginx</code> that can be used to associate any Ingress resources we create with this particular controller:</p> <pre><code>kubectl get ingressclass\n</code></pre>"},{"location":"setup/#next","title":"Next","text":"<p>The subsequent instructions reference various yaml artifacts that you will need to apply to your cluster at different points in time. You may obtain a copy of each file by copying and pasting directly from the instructions. It may be more practical however to clone this repository (see the GitHub link in the top bar); you will find the yaml files under the folder named <code>artifacts</code>.</p>"}]}